---
# DataOrb Pi Analytics Dashboard - Complete Installation Playbook
# ================================================================
# This playbook automates the complete installation and configuration of DataOrb
# on a Raspberry Pi Zero W with HyperPixel 2.1 Round display.
#
# COMPATIBILITY:
# - Raspberry Pi Zero W (ARMv6)
# - Raspberry Pi OS Bullseye (Legacy) - RECOMMENDED
# - HyperPixel 2.1 Round (480x480)
#
# FEATURES INSTALLED:
# - DataOrb analytics dashboard (React + Flask)
# - HyperPixel display drivers and configuration
# - Auto-start kiosk mode with Surf browser
# - WiFi Access Point fallback for network configuration
# - OTA update system
# - Clean boot experience
#
# USAGE:
# ansible-playbook -i hosts playbook.yml
#
# VARIABLES:
# - app_dir: Installation directory on the Pi
# - display_type: 'hyperpixel_round' or 'none' for headless

- name: Install DataOrb Analytics Dashboard on Raspberry Pi Zero W
  hosts: pi
  become: yes  # Run with sudo privileges
  vars:
    app_dir: /home/{{ ansible_user }}/pi-analytics-dashboard  # Where to install the app
    display_type: hyperpixel_round  # Display configuration: 'hyperpixel_round' or 'none'
    wifi_ap_ssid: DataOrb-Setup     # WiFi AP network name
    wifi_ap_password: dataorb123    # WiFi AP password (min 8 characters)
    
  tasks:
    # ============================================
    # Phase 1: System Preparation & Dependencies
    # ============================================
    # This phase detects the OS version and installs all required system packages.
    # Critical for ensuring compatibility with different Raspberry Pi OS versions.
    
    - name: Detect OS version
      # Detects the Raspberry Pi OS version (bullseye, bookworm, etc.)
      # This is critical for determining correct config file paths
      shell: |
        if [ -f /etc/os-release ]; then
          . /etc/os-release
          echo ${VERSION_CODENAME:-bullseye}
        else
          echo "unknown"
        fi
      register: os_detection
      changed_when: false  # This is just detection, no changes made
      tags: ['always']  # Always run this task
    
    - name: Set OS version fact
      set_fact:
        os_version: "{{ os_detection.stdout | lower }}"
      tags: ['always']
    
    - name: Display OS version
      debug:
        msg: "Detected OS: {{ os_version }}"
      tags: ['always']
    
    - name: Update package cache
      apt:
        update_cache: yes
        cache_valid_time: 3600
      tags: ['system', 'packages']
    
    - name: Install system dependencies
      # Core system packages required for the application
      apt:
        name:
          - git                      # For OTA updates via git
          - curl                     # For downloading resources
          - wget                     # Alternative downloader
          - unzip                    # For extracting archives
          - build-essential          # Compilation tools for Python packages
          - python3-dev              # Python development headers
          - python3-pip              # Python package installer
          - python3-venv             # Python virtual environments
          - python3-setuptools       # Python package setup tools
          - python3-wheel            # Python wheel package format
          - nginx                    # Web server (optional, not currently used)
          - xorg                     # X Window System
          - xinit                    # X server initializer
          - xserver-xorg-video-all  # Video drivers for X
          - xserver-xorg-input-all  # Input drivers for X
          - x11-xserver-utils        # X server utilities
          - unclutter                # Hide mouse cursor
          - matchbox-window-manager  # Lightweight window manager
          - fbi                      # Framebuffer image viewer
        state: present
      tags: ['system', 'dependencies']
    
    - name: Install lightweight browser for Pi Zero W
      # Surf is a minimal webkit browser perfect for Pi Zero W's limited resources
      # Midori is installed as a backup option
      apt:
        name:
          - surf      # Primary browser - very lightweight, webkit-based
          - midori    # Backup browser option
        state: present
      tags: ['system', 'browser']
    
    # ============================================
    # Phase 2: HyperPixel Display Configuration
    # ============================================
    # Configures the HyperPixel 2.1 Round display (480x480).
    # This is the most complex part as it requires specific kernel overlays
    # and timing configurations. Works best with Bullseye (Legacy OS).
    
    - name: Check OS version for display configuration
      # Different OS versions store boot config in different locations
      # Bullseye and earlier: /boot/
      # Bookworm and later: /boot/firmware/
      set_fact:
        config_path: "{{ '/boot/config.txt' if os_version in ['bullseye', 'buster'] else '/boot/firmware/config.txt' }}"
        overlay_dir: "{{ '/boot/overlays' if os_version in ['bullseye', 'buster'] else '/boot/firmware/overlays' }}"
        cmdline_path: "{{ '/boot/cmdline.txt' if os_version in ['bullseye', 'buster'] else '/boot/firmware/cmdline.txt' }}"
      tags: ['display']
    
    - name: Warn if using incompatible OS for HyperPixel
      debug:
        msg: 
          - "WARNING: HyperPixel 2.1 Round is NOT fully compatible with {{ os_version }}"
          - "For best results, use Raspberry Pi OS Legacy (Bullseye)"
      when: 
        - display_type == 'hyperpixel_round'
        - os_version not in ['bullseye', 'buster']
      tags: ['display']
    
    - name: Backup existing boot configuration
      copy:
        src: "{{ config_path }}"
        dest: "{{ config_path }}.backup.{{ ansible_date_time.epoch }}"
        remote_src: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'backup']
    
    - name: Install HyperPixel dependencies
      # Packages required for HyperPixel display communication and control
      apt:
        name:
          - git                # For cloning HyperPixel repo
          - python3-pip        # Python package manager
          - python3-smbus      # I2C/SMBus support
          - python3-spidev     # SPI interface
          - python3-numpy      # Numerical computations
          - python3-pil        # Python Imaging Library
          - python3-rpi.gpio   # GPIO control
          - i2c-tools          # I2C debugging tools
          - raspi-config       # Raspberry Pi configuration tool
          - device-tree-compiler  # For building device tree overlays
          - build-essential    # Compilation tools
        state: present
        update_cache: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    # Clone and install HyperPixel software
    - name: Clone HyperPixel2r repository
      git:
        repo: https://github.com/pimoroni/hyperpixel2r.git
        dest: /tmp/hyperpixel2r
        force: yes
      when: display_type == 'hyperpixel_round'
      register: hyperpixel_repo
      retries: 3
      delay: 10
      until: hyperpixel_repo is succeeded
      tags: ['display', 'hyperpixel']
    
    - name: Run official HyperPixel installer
      # The official installer properly builds and installs all components
      shell: |
        cd /tmp/hyperpixel2r
        if [ -f install.sh ]; then
          # Run the installer which:
          # - Builds the device tree overlay
          # - Installs hyperpixel2r-init binary
          # - Creates systemd service
          # - Configures boot settings
          sudo bash install.sh
        else
          echo "Warning: install.sh not found in repository"
          exit 1
        fi
      when: 
        - display_type == 'hyperpixel_round'
        - hyperpixel_repo is succeeded
      register: hyperpixel_install
      tags: ['display', 'hyperpixel']
    
    - name: Verify HyperPixel installation components
      # Check that all required components were installed
      stat:
        path: "{{ item }}"
      loop:
        - "{{ overlay_dir }}/hyperpixel2r.dtbo"
        - "/usr/bin/hyperpixel2r-init"
        - "/etc/systemd/system/hyperpixel2r-init.service"
      register: hyperpixel_components
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    - name: Display HyperPixel component status
      debug:
        msg: "{{ item.item }} - {{ 'Installed' if item.stat.exists else 'Missing' }}"
      loop: "{{ hyperpixel_components.results }}"
      when: 
        - display_type == 'hyperpixel_round'
        - hyperpixel_components is defined
      tags: ['display', 'hyperpixel']
    
    - name: Enable hyperpixel2r-init service
      systemd:
        name: hyperpixel2r-init
        enabled: yes
        daemon_reload: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel', 'services']
    
    # Clean existing configuration
    - name: Remove old HyperPixel configuration
      lineinfile:
        path: "{{ config_path }}"
        regexp: "{{ item }}"
        state: absent
      loop:
        - '.*hyperpixel.*'
        - '^enable_dpi_lcd='
        - '^dpi_group='
        - '^dpi_mode='
        - '^dpi_output_format='
        - '^dpi_timings='
        - '^display_rotate='
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    # Disable conflicting overlays
    - name: Disable conflicting KMS overlay
      replace:
        path: "{{ config_path }}"
        regexp: '^(dtoverlay=vc4-kms-v3d.*)$'
        replace: '#\1  # Disabled for HyperPixel'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Disable FKMS overlay
      replace:
        path: "{{ config_path }}"
        regexp: '^(dtoverlay=vc4-fkms-v3d.*)$'
        replace: '#\1  # Disabled for HyperPixel'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Remove any KMS DPI overlay for HyperPixel
      # The vc4-kms-dpi-hyperpixel2r overlay is for Bookworm but doesn't work well
      lineinfile:
        path: "{{ config_path }}"
        regexp: '^dtoverlay=vc4-kms-dpi-hyperpixel2r'
        state: absent
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Disable display auto-detect
      replace:
        path: "{{ config_path }}"
        regexp: '^(display_auto_detect=1)$'
        replace: '#\1  # Disabled for HyperPixel'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    # Enable required interfaces
    - name: Enable I2C interface
      lineinfile:
        path: "{{ config_path }}"
        regexp: '^#?dtparam=i2c_arm='
        line: 'dtparam=i2c_arm=on'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Enable SPI interface
      lineinfile:
        path: "{{ config_path }}"
        regexp: '^#?dtparam=spi='
        line: 'dtparam=spi=on'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Enable I2C via raspi-config
      command: raspi-config nonint do_i2c 0
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes
      changed_when: false
      tags: ['display']
    
    - name: Enable SPI via raspi-config
      command: raspi-config nonint do_spi 0
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes
      changed_when: false
      tags: ['display']
    
    # CRITICAL: Set GL driver to Legacy for HyperPixel compatibility
    - name: Check if GL driver commands are available
      command: raspi-config nonint get_gldriver
      register: gl_driver_available
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes
      changed_when: false
      tags: ['display', 'critical']
    
    - name: Set GL driver to Legacy (required for HyperPixel)
      # The Full KMS driver doesn't work with HyperPixel - must use Legacy
      command: raspi-config nonint do_gldriver G1
      when: 
        - display_type == 'hyperpixel_round'
        - gl_driver_available.rc == 0
      register: gl_driver_result
      changed_when: gl_driver_result.rc == 0
      ignore_errors: yes
      tags: ['display', 'critical']
    
    - name: Verify GL driver is set to Legacy
      command: raspi-config nonint get_gldriver
      register: gl_driver_check
      when: 
        - display_type == 'hyperpixel_round'
        - gl_driver_available.rc == 0
      changed_when: false
      tags: ['display']
    
    - name: Display GL driver status
      debug:
        msg: "GL Driver status: {{ gl_driver_check.stdout | default('unknown') }} (should be 1 for Legacy)"
      when: 
        - display_type == 'hyperpixel_round'
        - gl_driver_check is defined
      tags: ['display']
    
    - name: Add HyperPixel display configuration
      # Critical display timing configuration for HyperPixel 2.1 Round
      # These values are specific to the 480x480 round display
      blockinfile:
        path: "{{ config_path }}"
        marker: "# {mark} ANSIBLE MANAGED - HyperPixel 2.1 Round Display"
        block: |
          dtoverlay=hyperpixel2r          # Load HyperPixel 2 Round device tree overlay
          enable_dpi_lcd=1                # Enable DPI LCD interface
          dpi_group=2                     # Custom mode group
          dpi_mode=87                     # Custom display mode
          dpi_output_format=0x7f216       # 18-bit RGB format
          dpi_timings=480 0 10 16 55 480 0 15 60 15 0 0 0 60 0 19200000 6  # Display timings
          
          # Enable I2C and SPI for display communication
          dtparam=i2c_arm=on
          dtparam=spi=on
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    # Configure console output
    - name: Check cmdline.txt content
      slurp:
        src: "{{ cmdline_path }}"
      register: cmdline_content
      when: 
        - display_type == 'hyperpixel_round'
        - cmdline_path is defined
      ignore_errors: yes
      tags: ['display']
    
    - name: Add console=tty1 to cmdline if not present
      replace:
        path: "{{ cmdline_path }}"
        regexp: '^((?!.*console=tty1).*)$'
        replace: '\1 console=tty1'
      when: 
        - display_type == 'hyperpixel_round'
        - cmdline_path is defined
        - cmdline_content is defined
        - cmdline_content is succeeded
        - cmdline_content.content is defined
        - "'console=tty1' not in (cmdline_content.content | b64decode)"
      tags: ['display']
    
    - name: Add fbcon=map:0 to cmdline if not present
      replace:
        path: "{{ cmdline_path }}"
        regexp: '^((?!.*fbcon=map:0).*)$'
        replace: '\1 fbcon=map:0'
      when: 
        - display_type == 'hyperpixel_round'
        - cmdline_path is defined
        - cmdline_content is defined
        - cmdline_content is succeeded
        - cmdline_content.content is defined
        - "'fbcon=map:0' not in (cmdline_content.content | b64decode)"
      tags: ['display']
    
    - name: Add user to required groups for display
      user:
        name: "{{ ansible_user }}"
        groups: spi,i2c,gpio,video
        append: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Configure X server permissions for display
      copy:
        content: |
          allowed_users=anybody
          needs_root_rights=yes
        dest: /etc/X11/Xwrapper.config
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'xorg']
    
    - name: Set permissions for tty1
      file:
        path: /dev/tty1
        mode: '0666'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Verify HyperPixel overlay is installed
      stat:
        path: "{{ overlay_dir }}/hyperpixel2r.dtbo"
      register: overlay_check
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Display HyperPixel installation status
      debug:
        msg: 
          - "HyperPixel installation {{ 'successful' if overlay_check.stat.exists else 'may need manual intervention' }}"
          - "Overlay present: {{ overlay_check.stat.exists | default(false) }}"
          - "Config path: {{ config_path }}"
          - "OS Version: {{ os_version }}"
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    # Configure HyperPixel backlight control
    - name: Install raspi-gpio for backlight control
      apt:
        name: raspi-gpio
        state: present
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    - name: Create HyperPixel backlight enable script
      copy:
        content: |
          #!/bin/bash
          # Enable HyperPixel 2.1 Round backlight
          # GPIO 19 controls the backlight (HIGH = on)
          
          # Wait for system to stabilize
          sleep 5
          
          # Enable backlight using raspi-gpio
          raspi-gpio set 19 op dh 2>/dev/null || {
              # Fallback to sysfs method if raspi-gpio fails
              echo 19 > /sys/class/gpio/export 2>/dev/null
              sleep 0.5
              echo out > /sys/class/gpio/gpio19/direction 2>/dev/null
              echo 1 > /sys/class/gpio/gpio19/value 2>/dev/null
          }
          
          # Log backlight activation
          echo "HyperPixel backlight enabled at $(date)" >> /var/log/hyperpixel-backlight.log
        dest: /usr/local/bin/hyperpixel-backlight.sh
        mode: '0755'
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    - name: Add backlight enable to rc.local before exit
      lineinfile:
        path: /etc/rc.local
        insertbefore: '^exit 0'
        line: '/usr/local/bin/hyperpixel-backlight.sh &'
        create: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    - name: Create systemd service for HyperPixel backlight
      copy:
        content: |
          [Unit]
          Description=HyperPixel Display Backlight Control
          After=sysinit.target
          Before=getty.target
          
          [Service]
          Type=oneshot
          ExecStart=/usr/local/bin/hyperpixel-backlight.sh
          RemainAfterExit=yes
          
          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/hyperpixel-backlight.service
        mode: '0644'
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel', 'services']
    
    - name: Enable HyperPixel backlight service
      systemd:
        name: hyperpixel-backlight
        enabled: yes
        daemon_reload: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel', 'services']
    
    # ============================================
    # Phase 3: Clean Boot Configuration
    # ============================================
    # Configures a professional, clean boot experience with no text output.
    # Sets up auto-login and hides all boot messages.
    
    # Install unclutter for hiding cursor
    - name: Install display utilities
      apt:
        name:
          - unclutter
        state: present
      tags: ['boot', 'display']
    
    # Configure completely silent boot
    - name: Backup cmdline.txt
      copy:
        src: "{{ cmdline_path }}"
        dest: "{{ cmdline_path }}.backup.{{ ansible_date_time.epoch }}"
        remote_src: yes
      tags: ['boot', 'backup']
    
    - name: Configure clean boot parameters
      replace:
        path: "{{ cmdline_path }}"
        regexp: '^(.*)$'
        replace: '\1 quiet loglevel=3 logo.nologo'
      tags: ['boot', 'clean']
    
    - name: Configure clean boot in config.txt
      blockinfile:
        path: "{{ config_path }}"
        marker: "# {mark} ANSIBLE MANAGED - Clean Boot"
        block: |
          disable_splash=1
      tags: ['boot', 'clean']
    
    # Configure auto-login
    - name: Create auto-login directory
      file:
        path: /etc/systemd/system/getty@tty1.service.d
        state: directory
        mode: '0755'
      tags: ['boot', 'autologin']
    
    - name: Configure auto-login
      copy:
        content: |
          [Service]
          ExecStart=
          ExecStart=-/sbin/agetty --autologin {{ ansible_user }} --noclear %I $TERM
          Type=idle
        dest: /etc/systemd/system/getty@tty1.service.d/autologin.conf
        mode: '0644'
      tags: ['boot', 'autologin']
    
    # Hide all login messages
    - name: Create empty login message files
      file:
        path: "{{ item }}"
        state: touch
        mode: '0644'
      loop:
        - /etc/issue
        - /etc/issue.net
        - /etc/motd
      tags: ['boot', 'silent']
    
    - name: Clear legal notice
      copy:
        content: ""
        dest: /etc/legal
        mode: '0644'
      tags: ['boot', 'silent']
    
    - name: Create .hushlogin for silent login
      file:
        path: "/home/{{ ansible_user }}/.hushlogin"
        state: touch
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      tags: ['boot', 'silent']
    
    # Optimize boot speed
    - name: Disable unnecessary services for faster boot
      systemd:
        name: "{{ item }}"
        enabled: no
        state: stopped
      loop:
        - bluetooth.service
        - hciuart.service
        - apt-daily.service
        - apt-daily-upgrade.service
        - man-db.service
      ignore_errors: yes
      tags: ['boot', 'optimize']
    
    # ============================================
    # Phase 4: Create swap file for Pi Zero W
    # ============================================
    # Pi Zero W has limited RAM (512MB). A swap file helps prevent
    # out-of-memory errors during npm builds and normal operation.
    
    - name: Check if swap file exists
      stat:
        path: /swapfile
      register: swap_file_check
      tags: ['swap']
    
    - name: Create swap file (1GB for Pi Zero W)
      # Creates a 1GB swap file to supplement the 512MB RAM
      command: |
        dd if=/dev/zero of=/swapfile bs=1M count=1024
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Set swap file permissions
      file:
        path: /swapfile
        mode: '0600'
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Make swap file
      command: mkswap /swapfile
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Enable swap file
      command: swapon /swapfile
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Add swap to fstab
      lineinfile:
        path: /etc/fstab
        line: '/swapfile none swap sw 0 0'
        create: yes
      tags: ['swap']
    
    # ============================================
    # Phase 5: Application Deployment
    # ============================================
    # Copies the DataOrb application files to the Pi and installs
    # all Node.js and Python dependencies.
    
    - name: Create application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: ['app']
    
    - name: Create temporary archive of application
      # Creates a compressed archive of the application code, excluding:
      # - Version control files (.git)
      # - Dependencies (node_modules) - will be installed on Pi
      # - Python cache files
      # - Environment files with secrets
      # - Ansible playbooks (not needed on Pi)
      archive:
        path: "../"
        dest: "/tmp/pi-analytics-app.tar.gz"
        format: gz
        exclude_path:
          - "../.git"           # Version control
          - "../node_modules"   # Node dependencies (reinstalled)
          - "../__pycache__"    # Python cache
          - "../*.pyc"          # Compiled Python files
          - "../.env"           # Secrets file (no longer used)
          - "../ansible"        # Deployment files
          - "../lcd_test"       # Test files
          - "../frontend/node_modules"  # Frontend dependencies
          - "../backend/venv"   # Python virtual environment
          - "../backend/__pycache__"  # Backend Python cache
      delegate_to: localhost   # Run on control machine
      become: no
      run_once: true
      tags: ['app', 'deploy']
    
    - name: Copy application archive to Pi
      copy:
        src: "/tmp/pi-analytics-app.tar.gz"
        dest: "/tmp/pi-analytics-app.tar.gz"
      tags: ['app', 'deploy']
    
    - name: Extract application files
      unarchive:
        src: "/tmp/pi-analytics-app.tar.gz"
        dest: "{{ app_dir }}"
        remote_src: yes
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      tags: ['app', 'deploy']
    
    - name: Clean up archive on Pi
      file:
        path: "/tmp/pi-analytics-app.tar.gz"
        state: absent
      tags: ['app', 'deploy']
    
    - name: Clean up local archive
      file:
        path: "/tmp/pi-analytics-app.tar.gz"
        state: absent
      delegate_to: localhost
      become: no
      run_once: true
      tags: ['app', 'deploy']
    
    - name: Check current Node.js version
      command: node --version
      register: current_node_version
      changed_when: false
      failed_when: false
      tags: ['app', 'nodejs']
    
    - name: Display current Node.js version
      debug:
        msg: "Current Node.js version: {{ current_node_version.stdout | default('Not installed') }}"
      tags: ['app', 'nodejs']
    
    - name: Install Node.js 16.x (compatible with Pi Zero W)
      # Pi Zero W uses ARMv6 which is not supported by NodeSource
      # We use unofficial builds for ARMv6 or NodeSource for ARMv7+
      block:
        - name: Detect Pi architecture
          command: uname -m
          register: pi_arch
          changed_when: false
          tags: ['app', 'nodejs']
        
        - name: Install Node.js for ARMv6 (Pi Zero W)
          when: pi_arch.stdout == 'armv6l'
          block:
            - name: Remove old Node.js if present
              apt:
                name: 
                  - nodejs
                  - npm
                state: absent
              ignore_errors: yes
              tags: ['app', 'nodejs']
            
            - name: Download Node.js 16 for ARMv6
              get_url:
                url: https://unofficial-builds.nodejs.org/download/release/v16.20.2/node-v16.20.2-linux-armv6l.tar.xz
                dest: /tmp/node-v16.20.2-linux-armv6l.tar.xz
                mode: '0644'
                timeout: 60
              retries: 3
              delay: 10
              tags: ['app', 'nodejs']
            
            - name: Extract Node.js to /usr/local
              unarchive:
                src: /tmp/node-v16.20.2-linux-armv6l.tar.xz
                dest: /usr/local
                remote_src: yes
                extra_opts: [--strip-components=1]
              tags: ['app', 'nodejs']
            
            - name: Update PATH for Node.js
              lineinfile:
                path: /etc/profile
                line: 'export PATH=/usr/local/bin:$PATH'
                create: yes
              tags: ['app', 'nodejs']
            
            - name: Create symlinks for compatibility
              file:
                src: "/usr/local/bin/{{ item }}"
                dest: "/usr/bin/{{ item }}"
                state: link
                force: yes
              loop:
                - node
                - npm
                - npx
              ignore_errors: yes
              tags: ['app', 'nodejs']
        
        - name: Install Node.js for ARMv7+ (Pi 2/3/4)
          when: pi_arch.stdout != 'armv6l'
          shell: |
            curl -fsSL https://deb.nodesource.com/setup_16.x | bash -
            apt-get install -y nodejs
          environment:
            DEBIAN_FRONTEND: noninteractive
          tags: ['app', 'nodejs']
      when: current_node_version.rc != 0 or current_node_version.stdout is version('v14.0.0', '<')
    
    - name: Verify Node.js installation
      shell: |
        export PATH=/usr/local/bin:$PATH
        which node && node --version
      register: node_version
      changed_when: false
      failed_when: false
      tags: ['app', 'nodejs']
    
    - name: Wait for Node.js to be available  
      shell: |
        export PATH=/usr/local/bin:$PATH
        node --version
      register: node_version_retry
      until: node_version_retry.rc == 0
      retries: 5
      delay: 10
      when: node_version.rc != 0
      tags: ['app', 'nodejs']
    
    - name: Set final node version
      set_fact:
        final_node_version: "{{ (node_version.stdout_lines[-1] if node_version.rc == 0 else node_version_retry.stdout) | default('unknown') }}"
      tags: ['app', 'nodejs']
    
    - name: Display installed Node.js version
      debug:
        msg: "Installed Node.js version: {{ final_node_version }}"
      tags: ['app', 'nodejs']
    
    - name: Verify npm is installed
      shell: |
        export PATH=/usr/local/bin:$PATH
        npm --version
      register: npm_version
      changed_when: false
      failed_when: false
      tags: ['app', 'nodejs']
    
    - name: Display npm version
      debug:
        msg: "npm version: {{ npm_version.stdout }}"
      tags: ['app', 'nodejs']
    
    - name: Check if frontend directory exists
      stat:
        path: "{{ app_dir }}/frontend/package.json"
      register: frontend_package
      tags: ['app', 'frontend']
    
    - name: Install frontend dependencies with memory limit
      # Pi Zero W has limited memory, so we restrict Node.js heap size
      # --no-audit and --no-fund speed up installation
      shell: |
        export NODE_OPTIONS="--max-old-space-size=256"
        npm install --no-audit --no-fund
      args:
        chdir: "{{ app_dir }}/frontend"
        creates: "{{ app_dir }}/frontend/node_modules"  # Skip if already installed
      become_user: "{{ ansible_user }}"
      register: npm_install
      retries: 2        # Retry on failure (network issues)
      delay: 10         # Wait 10 seconds between retries
      until: npm_install.rc == 0
      when: frontend_package.stat.exists
      tags: ['app', 'frontend']
    
    - name: Build frontend with memory limit
      # Build the React app with optimized memory settings for Pi Zero W
      shell: |
        export NODE_OPTIONS="--max-old-space-size=384"  # Slightly more memory for build process
        npm run build
      args:
        chdir: "{{ app_dir }}/frontend"
        creates: "{{ app_dir }}/frontend/build"  # Skip if build exists
      become_user: "{{ ansible_user }}"
      when: frontend_package.stat.exists
      register: npm_build
      retries: 2        # Retry on failure
      delay: 10
      until: npm_build.rc == 0
      failed_when: false  # Continue even if build fails
      tags: ['app', 'frontend', 'build']
    
    - name: Check if frontend build succeeded
      fail:
        msg: |
          Frontend build failed! This is usually due to memory constraints on Pi Zero W.
          Try:
          1. Increase swap: sudo dphys-swapfile swapoff && sudo nano /etc/dphys-swapfile (CONF_SWAPSIZE=1024)
          2. Build on another machine and copy the build folder
          3. Run: cd {{ app_dir }}/frontend && NODE_OPTIONS="--max-old-space-size=256" npm run build
      when: 
        - frontend_package.stat.exists
        - npm_build.rc is defined
        - npm_build.rc != 0
      tags: ['app', 'frontend', 'build']
    
    - name: Check if backend directory exists
      stat:
        path: "{{ app_dir }}/backend/requirements.txt"
      register: backend_requirements
      tags: ['app', 'backend']
    
    - name: Remove existing virtual environment if broken
      file:
        path: "{{ app_dir }}/backend/venv"
        state: absent
      when: backend_requirements.stat.exists
      tags: ['app', 'backend']
    
    - name: Create Python virtual environment with pip
      # Creates isolated Python environment for backend dependencies
      # Includes fallback to install pip if not present in venv
      shell: |
        cd {{ app_dir }}/backend
        python3 -m venv venv                              # Create virtual environment
        if ! ./venv/bin/python -c "import pip" 2>/dev/null; then
          # If pip is missing, install it manually
          curl -sS https://bootstrap.pypa.io/get-pip.py | ./venv/bin/python
        fi
      become_user: "{{ ansible_user }}"
      when: backend_requirements.stat.exists
      tags: ['app', 'backend']
    
    - name: Install Python dependencies
      shell: |
        cd {{ app_dir }}/backend
        ./venv/bin/python -m pip install --no-cache-dir -r requirements.txt || ./venv/bin/pip install --no-cache-dir -r requirements.txt
      args:
        chdir: "{{ app_dir }}/backend"
      become_user: "{{ ansible_user }}"
      when: backend_requirements.stat.exists
      register: pip_install
      retries: 2
      delay: 10
      until: pip_install.rc == 0
      tags: ['app', 'backend']
    
    - name: Create default device_config.json if not exists
      copy:
        content: |
          {
            "posthog": {
              "api_key": "",
              "project_id": "",
              "host": "https://eu.posthog.com"
            },
            "display": {
              "refresh_interval": 30,
              "theme": "posthog",
              "brightness": 100,
              "rotation": 0,
              "screensaver_timeout": 0,
              "metrics": {
                "classic": {
                  "top": {
                    "type": "events_24h",
                    "label": "Events",
                    "enabled": true
                  },
                  "left": {
                    "type": "unique_users_24h",
                    "label": "Users",
                    "enabled": true
                  },
                  "right": {
                    "type": "page_views_24h",
                    "label": "Views",
                    "enabled": true
                  }
                },
                "analytics": {
                  "center": {
                    "type": "events_24h",
                    "label": "Events Today",
                    "enabled": true
                  }
                }
              }
            },
            "network": {
              "wifi_country": "US"
            },
            "ota": {
              "enabled": true,
              "branch": "main",
              "check_on_boot": true,
              "auto_pull": false,
              "last_update": null
            },
            "demo_mode": false
          }
        dest: "{{ app_dir }}/backend/device_config.json"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
        force: no  # Don't overwrite if exists
      tags: ['app', 'config']
    
    
    # ============================================
    # Phase 6: System Services Setup
    # ============================================
    # Sets up systemd services and auto-start scripts for the dashboard.
    # Includes X server configuration and kiosk mode setup.
    
    # Install X server and display tools
    - name: Install X server and display tools
      apt:
        name:
          - xserver-xorg
          - xinit
          - x11-xserver-utils
          - matchbox-window-manager
          - unclutter
          - surf
        state: present
      tags: ['display', 'xorg']
    
    - name: Create backend service
      template:
        src: templates/pi-analytics-backend.service.j2
        dest: /etc/systemd/system/pi-analytics-backend.service
      tags: ['services', 'backend']
    
    - name: Create display service
      template:
        src: templates/pi-analytics-display.service.j2
        dest: /etc/systemd/system/pi-analytics-display.service
      vars:
        app_user: "{{ ansible_user }}"
        backend_port: 80
      tags: ['services', 'display']
    
    # NOTE: Removed kiosk autostart script and rc.local entry
    # The pi-analytics-display systemd service now handles all X server
    # and browser startup, avoiding conflicts with multiple X sessions
    
    - name: Remove old autostart from rc.local if exists
      lineinfile:
        path: /etc/rc.local
        line: '/usr/local/bin/pi-dashboard-autostart.sh &'
        state: absent
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk', 'cleanup']
    
    - name: Make rc.local executable
      file:
        path: /etc/rc.local
        mode: '0755'
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Enable rc-local service
      systemd:
        name: rc-local
        enabled: yes
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes
      tags: ['services', 'kiosk']
    
    - name: Create X11 config directory
      file:
        path: /etc/X11/xorg.conf.d
        state: directory
        mode: '0755'
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'xorg']
    
    - name: Create X server configuration for HyperPixel
      # Force X to use fb0 (HyperPixel) instead of fb1 (HDMI)
      copy:
        content: |
          Section "Device"
              Identifier "HyperPixel"
              Driver "fbdev"
              Option "fbdev" "/dev/fb0"
          EndSection
          
          Section "Screen"
              Identifier "HyperPixelScreen"
              Device "HyperPixel"
              DefaultDepth 24
          EndSection
          
          Section "ServerLayout"
              Identifier "HyperPixelLayout"
              Screen "HyperPixelScreen"
          EndSection
        dest: /etc/X11/xorg.conf.d/99-hyperpixel.conf
        mode: '0644'
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'xorg', 'kiosk']
    
    - name: Create scripts directory
      file:
        path: "{{ app_dir }}/scripts"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Create display start script
      # This script starts matchbox window manager and surf browser
      copy:
        content: |
          #!/bin/bash
          # Start display components for Pi Analytics Dashboard
          
          # Start matchbox window manager (no decorations, no cursor)
          matchbox-window-manager -use_titlebar no -use_cursor no &
          sleep 2
          
          # Start surf browser in fullscreen
          exec surf -F http://localhost:{{ backend_port | default(80) }}
        dest: "{{ app_dir }}/scripts/start-display.sh"
        mode: '0755'
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Create kiosk start script
      template:
        src: templates/start-kiosk.sh.j2
        dest: "{{ app_dir }}/start-kiosk.sh"
        mode: '0755'
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Verify kiosk script was created
      stat:
        path: "{{ app_dir }}/start-kiosk.sh"
      register: kiosk_script_check
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Display kiosk script status
      debug:
        msg: "Kiosk script created successfully at {{ app_dir }}/start-kiosk.sh"
      when: 
        - display_type == 'hyperpixel_round'
        - kiosk_script_check.stat.exists
      tags: ['services', 'kiosk']
    
    - name: Configure auto-start in user's .bashrc
      # Alternative auto-start method via .bashrc
      # This runs when the user logs in on tty1 (the physical display)
      blockinfile:
        path: "/home/{{ ansible_user }}/.bashrc"
        marker: "# {mark} ANSIBLE MANAGED - DataOrb Dashboard Auto-start"
        block: |
          # Auto-start DataOrb Dashboard on tty1 (physical display)
          if [ "$(tty 2>/dev/null)" = "/dev/tty1" ]; then
              # Only start if X server not already running
              if ! pgrep -x "Xorg" > /dev/null; then
                  echo "Starting DataOrb Dashboard..."
                  cd {{ app_dir }}
                  startx ./start-kiosk.sh -- :0 vt1  # Start X on virtual terminal 1
              fi
          fi
      tags: ['services', 'kiosk', 'autostart']
    
    - name: Check if nginx is installed and running
      shell: |
        if systemctl is-active nginx >/dev/null 2>&1; then
          echo "running"
        else
          echo "not_running"
        fi
      register: nginx_status
      tags: ['services']
    
    - name: Stop nginx if it's blocking port 80
      systemd:
        name: nginx
        state: stopped
        enabled: no
      when: nginx_status.stdout == 'running'
      ignore_errors: yes
      tags: ['services']
    
    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes
      tags: ['services']
    
    - name: Enable and start backend service
      systemd:
        name: pi-analytics-backend
        enabled: yes
        state: restarted  # Use restarted to ensure latest code is running
      tags: ['services', 'backend']
    
    - name: Enable and start display service
      systemd:
        name: pi-analytics-display
        enabled: yes
        state: started  # Start the service immediately
        daemon_reload: yes
      tags: ['services', 'display']
    
    # ============================================
    # Phase 7: WiFi Access Point Setup
    # ============================================
    # Configures automatic WiFi Access Point mode when no network is available.
    # This allows users to connect to the Pi and configure WiFi settings
    # even when it's not connected to a network.
    
    - name: Install WiFi AP packages
      # Packages needed to create a WiFi access point
      apt:
        name:
          - hostapd         # Access point daemon
          - dnsmasq         # DHCP and DNS server
          - iw              # Wireless configuration tool
          - wireless-tools  # Legacy wireless tools
        state: present
      tags: ['wifi', 'ap']
    
    - name: Check if WiFi AP manager script exists
      stat:
        path: ../scripts/wifi-ap-manager.sh
      delegate_to: localhost
      register: wifi_script_check
      become: no
      tags: ['wifi', 'ap']
    
    - name: Copy WiFi AP manager script
      copy:
        src: ../scripts/wifi-ap-manager.sh
        dest: "{{ app_dir }}/scripts/wifi-ap-manager.sh"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      when: wifi_script_check.stat.exists
      tags: ['wifi', 'ap']
    
    - name: Warn if WiFi AP script is missing
      debug:
        msg: "WARNING: WiFi AP manager script not found. WiFi fallback AP mode will not be available."
      when: not wifi_script_check.stat.exists
      tags: ['wifi', 'ap']
    
    - name: Create WiFi AP manager service
      # Service that checks network connectivity and starts AP if needed
      copy:
        content: |
          [Unit]
          Description=DataOrb WiFi Access Point Manager
          After=network.target
          Wants=network-online.target
          
          [Service]
          Type=oneshot
          ExecStart={{ app_dir }}/scripts/wifi-ap-manager.sh check
          RemainAfterExit=yes
          StandardOutput=journal
          StandardError=journal
          
          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/pi-analytics-wifi-ap.service
        mode: '0644'
      tags: ['wifi', 'ap', 'services']
    
    - name: Create WiFi check timer
      copy:
        content: |
          [Unit]
          Description=DataOrb WiFi connectivity check timer
          Requires=pi-analytics-wifi-check.service
          
          [Timer]
          OnBootSec=30
          OnUnitActiveSec=60
          
          [Install]
          WantedBy=timers.target
        dest: /etc/systemd/system/pi-analytics-wifi-check.timer
        mode: '0644'
      tags: ['wifi', 'ap', 'services']
    
    - name: Create WiFi check service
      copy:
        content: |
          [Unit]
          Description=DataOrb WiFi check and AP fallback
          
          [Service]
          Type=oneshot
          ExecStart={{ app_dir }}/scripts/wifi-ap-manager.sh check
          StandardOutput=journal
          StandardError=journal
        dest: /etc/systemd/system/pi-analytics-wifi-check.service
        mode: '0644'
      tags: ['wifi', 'ap', 'services']
    
    - name: Configure hostapd defaults
      copy:
        content: |
          DAEMON_CONF="/etc/hostapd/hostapd.conf"
        dest: /etc/default/hostapd
        mode: '0644'
      tags: ['wifi', 'ap']
    
    - name: Enable WiFi AP services
      systemd:
        name: "{{ item }}"
        enabled: yes
        daemon_reload: yes
      loop:
        - pi-analytics-wifi-ap.service
        - pi-analytics-wifi-check.timer
      when: wifi_script_check.stat.exists
      tags: ['wifi', 'ap', 'services']
    
    - name: Disable conflicting services
      # Disable default hostapd/dnsmasq services as we manage them manually
      systemd:
        name: "{{ item }}"
        enabled: no
        state: stopped
      loop:
        - hostapd.service    # We start this manually when needed
        - dnsmasq.service    # We start this manually when needed
      ignore_errors: yes     # Services might not exist
      tags: ['wifi', 'ap', 'services']
    
    # ============================================
    # Phase 8: Final Configuration
    # ============================================
    # Final permission fixes, log directory creation, and
    # installation summary display.
    
    - name: Set correct permissions on application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        recurse: yes
      tags: ['permissions']
    
    - name: Create log directory
      file:
        path: /var/log/pi-analytics
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: ['logs']
    
    # ============================================
    # Phase 9: Health Checks
    # ============================================
    # Verify that all services are running correctly
    
    - name: Check which port backend is using
      shell: |
        if curl -s http://localhost:80/api/health >/dev/null 2>&1; then
          echo "80"
        elif curl -s http://localhost:5000/api/health >/dev/null 2>&1; then
          echo "5000"
        else
          echo "none"
        fi
      register: backend_port
      tags: ['healthcheck']
    
    - name: Display backend port
      debug:
        msg: "Backend is running on port: {{ backend_port.stdout }}"
      tags: ['healthcheck']
    
    - name: Wait for backend service to be ready
      wait_for:
        port: "{{ backend_port.stdout | default('5000') }}"
        host: localhost
        delay: 5
        timeout: 60
      when: backend_port.stdout != 'none'
      tags: ['healthcheck']
    
    - name: Check backend API health
      uri:
        url: "http://localhost:{{ backend_port.stdout | default('5000') }}/api/health"
        method: GET
        status_code: 200
      register: api_health
      retries: 3
      delay: 5
      until: api_health.status == 200
      when: backend_port.stdout != 'none'
      failed_when: false  # Don't fail, just check
      tags: ['healthcheck']
    
    - name: Check if frontend is accessible
      uri:
        url: "http://localhost:{{ backend_port.stdout | default('5000') }}/"
        method: GET
        status_code: 200
      register: frontend_health
      retries: 3
      delay: 5
      until: frontend_health.status == 200
      when: backend_port.stdout != 'none'
      failed_when: false  # Don't fail, just check
      tags: ['healthcheck']
    
    - name: Verify systemd services are active
      systemd:
        name: "{{ item }}"
        state: started
      register: service_status
      failed_when: false
      loop:
        - pi-analytics-backend
        - pi-analytics-wifi-ap
      tags: ['healthcheck']
    
    - name: Display service status
      debug:
        msg: "Service {{ item.item }} is {{ 'active' if item.changed == false else 'was started' }}"
      loop: "{{ service_status.results }}"
      tags: ['healthcheck']
    
    - name: Display installation summary
      # Show helpful information about the completed installation
      debug:
        msg:
          - "====================================="
          - "DataOrb Analytics Dashboard Installation Complete!"
          - "====================================="
          - ""
          - "Application installed at: {{ app_dir }}"
          - "Backend service: systemctl status pi-analytics-backend"
          - "Display service: systemctl status pi-analytics-display"
          - ""
          - "Access the dashboard at: http://{{ ansible_host }}{{ ':5000' if backend_port.stdout == '5000' else '' }}"
          - "Configure DataOrb Settings: http://{{ ansible_host }}{{ ':5000' if backend_port.stdout == '5000' else '' }}/config"
          - ""
          - "WiFi AP Mode (when no network):"
          - "  SSID: {{ wifi_ap_ssid }}"
          - "  Password: {{ wifi_ap_password }}"
          - "  Config URL: http://192.168.4.1"
          - ""
          - "{{ 'Display: HyperPixel 2.1 Round with matchbox + surf browser' if display_type == 'hyperpixel_round' else '' }}"
          - ""
          - "{{ ' CRITICAL: REBOOT REQUIRED for HyperPixel display!' if display_type == 'hyperpixel_round' else '' }}"
          - "{{ 'The framebuffer devices are created only after reboot.' if display_type == 'hyperpixel_round' else '' }}"
          - "{{ 'Without reboot, X server will show: no screens found' if display_type == 'hyperpixel_round' else '' }}"
          - ""
          - "{{ 'REBOOT NOW: sudo reboot' if display_type == 'hyperpixel_round' else '' }}"
          - ""
          - "{{ 'After reboot, display will auto-start via pi-analytics-display service' if display_type == 'hyperpixel_round' else '' }}"
          - ""
          - "Configuration: All settings managed via device_config.json"
          - "{{ 'OS: ' + os_version + ' (HyperPixel works best with Bullseye)' }}"
          - "====================================="
      tags: ['always']
    
  # Handlers are triggered by tasks using 'notify'
  # They run at the end of the play
  handlers:
    - name: restart backend
      systemd:
        name: pi-analytics-backend
        state: restarted