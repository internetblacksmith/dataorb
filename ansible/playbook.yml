---
# Pi Analytics Dashboard - Complete Installation Playbook
# This playbook installs and configures the complete Pi Analytics Dashboard
# including HyperPixel display setup, application deployment, and auto-start services

- name: Install Pi Analytics Dashboard on Raspberry Pi Zero W
  hosts: pi
  become: yes
  vars:
    app_dir: /home/{{ ansible_user }}/pi-analytics-dashboard
    display_type: hyperpixel_round  # Can be 'hyperpixel_round' or 'none'
    
  tasks:
    # ============================================
    # Phase 1: System Preparation & Dependencies
    # ============================================
    
    - name: Detect OS version
      shell: |
        if [ -f /etc/os-release ]; then
          . /etc/os-release
          echo ${VERSION_CODENAME:-bullseye}
        else
          echo "unknown"
        fi
      register: os_detection
      changed_when: false
      tags: ['always']
    
    - name: Set OS version fact
      set_fact:
        os_version: "{{ os_detection.stdout | lower }}"
      tags: ['always']
    
    - name: Display OS version
      debug:
        msg: "Detected OS: {{ os_version }}"
      tags: ['always']
    
    - name: Update package cache
      apt:
        update_cache: yes
        cache_valid_time: 3600
      tags: ['system', 'packages']
    
    - name: Install system dependencies
      apt:
        name:
          - git
          - curl
          - wget
          - unzip
          - build-essential
          - python3-dev
          - python3-pip
          - python3-venv
          - python3-setuptools
          - python3-wheel
          - nginx
          - xorg
          - xinit
          - xserver-xorg-video-all
          - xserver-xorg-input-all
          - x11-xserver-utils
          - unclutter
          - matchbox-window-manager
          - fbi
        state: present
      tags: ['system', 'dependencies']
    
    - name: Install lightweight browser for Pi Zero W
      apt:
        name:
          - surf
          - midori
        state: present
      tags: ['system', 'browser']
    
    # ============================================
    # Phase 2: HyperPixel Display Configuration
    # Optimized for Bullseye (Legacy OS)
    # ============================================
    
    - name: Check OS version for display configuration
      set_fact:
        config_path: "{{ '/boot/config.txt' if os_version in ['bullseye', 'buster'] else '/boot/firmware/config.txt' }}"
        overlay_dir: "{{ '/boot/overlays' if os_version in ['bullseye', 'buster'] else '/boot/firmware/overlays' }}"
        cmdline_path: "{{ '/boot/cmdline.txt' if os_version in ['bullseye', 'buster'] else '/boot/firmware/cmdline.txt' }}"
      tags: ['display']
    
    - name: Warn if using incompatible OS for HyperPixel
      debug:
        msg: 
          - "WARNING: HyperPixel 2.1 Round is NOT fully compatible with {{ os_version }}"
          - "For best results, use Raspberry Pi OS Legacy (Bullseye)"
      when: 
        - display_type == 'hyperpixel_round'
        - os_version not in ['bullseye', 'buster']
      tags: ['display']
    
    - name: Backup existing boot configuration
      copy:
        src: "{{ config_path }}"
        dest: "{{ config_path }}.backup.{{ ansible_date_time.epoch }}"
        remote_src: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'backup']
    
    # Install HyperPixel dependencies
    - name: Install HyperPixel dependencies
      apt:
        name:
          - git
          - python3-pip
          - python3-smbus
          - python3-spidev
          - python3-numpy
          - python3-pil
          - python3-rpi.gpio
          - i2c-tools
          - raspi-config
        state: present
        update_cache: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    # Clone and install HyperPixel software
    - name: Clone HyperPixel2r repository
      git:
        repo: https://github.com/pimoroni/hyperpixel2r.git
        dest: /tmp/hyperpixel2r
        force: yes
      when: display_type == 'hyperpixel_round'
      register: hyperpixel_repo
      tags: ['display', 'hyperpixel']
    
    - name: Run HyperPixel installer if it exists
      shell: |
        cd /tmp/hyperpixel2r
        if [ -f install.sh ]; then
          yes | bash install.sh || true
        fi
      when: 
        - display_type == 'hyperpixel_round'
        - hyperpixel_repo is succeeded
      ignore_errors: yes
      tags: ['display', 'hyperpixel']
    
    - name: Copy overlay from repository if needed
      shell: |
        if [ ! -f {{ overlay_dir }}/hyperpixel2r.dtbo ]; then
          if [ -f /tmp/hyperpixel2r/dist/hyperpixel2r.dtbo ]; then
            cp /tmp/hyperpixel2r/dist/hyperpixel2r.dtbo {{ overlay_dir }}/
          fi
        fi
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    # Clean existing configuration
    - name: Remove old HyperPixel configuration
      lineinfile:
        path: "{{ config_path }}"
        regexp: "{{ item }}"
        state: absent
      loop:
        - '.*hyperpixel.*'
        - '^enable_dpi_lcd='
        - '^dpi_group='
        - '^dpi_mode='
        - '^dpi_output_format='
        - '^dpi_timings='
        - '^display_rotate='
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    # Disable conflicting overlays
    - name: Disable conflicting KMS overlay
      replace:
        path: "{{ config_path }}"
        regexp: '^(dtoverlay=vc4-kms-v3d.*)$'
        replace: '#\1  # Disabled for HyperPixel'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Disable FKMS overlay
      replace:
        path: "{{ config_path }}"
        regexp: '^(dtoverlay=vc4-fkms-v3d.*)$'
        replace: '#\1  # Disabled for HyperPixel'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Disable display auto-detect
      replace:
        path: "{{ config_path }}"
        regexp: '^(display_auto_detect=1)$'
        replace: '#\1  # Disabled for HyperPixel'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    # Enable required interfaces
    - name: Enable I2C interface
      lineinfile:
        path: "{{ config_path }}"
        regexp: '^#?dtparam=i2c_arm='
        line: 'dtparam=i2c_arm=on'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Enable SPI interface
      lineinfile:
        path: "{{ config_path }}"
        regexp: '^#?dtparam=spi='
        line: 'dtparam=spi=on'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Enable I2C via raspi-config
      command: raspi-config nonint do_i2c 0
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes
      changed_when: false
      tags: ['display']
    
    - name: Enable SPI via raspi-config
      command: raspi-config nonint do_spi 0
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes
      changed_when: false
      tags: ['display']
    
    # Add HyperPixel configuration
    - name: Add HyperPixel display configuration
      blockinfile:
        path: "{{ config_path }}"
        marker: "# {mark} ANSIBLE MANAGED - HyperPixel 2.1 Round Display"
        block: |
          dtoverlay=hyperpixel2r
          enable_dpi_lcd=1
          dpi_group=2
          dpi_mode=87
          dpi_output_format=0x7f216
          dpi_timings=480 0 10 16 55 480 0 15 60 15 0 0 0 60 0 19200000 6
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    # Configure console output
    - name: Check cmdline.txt content
      slurp:
        src: "{{ cmdline_path }}"
      register: cmdline_content
      when: 
        - display_type == 'hyperpixel_round'
        - cmdline_path is defined
      ignore_errors: yes
      tags: ['display']
    
    - name: Add console=tty1 to cmdline if not present
      replace:
        path: "{{ cmdline_path }}"
        regexp: '^((?!.*console=tty1).*)$'
        replace: '\1 console=tty1'
      when: 
        - display_type == 'hyperpixel_round'
        - cmdline_path is defined
        - cmdline_content is defined
        - cmdline_content is succeeded
        - cmdline_content.content is defined
        - "'console=tty1' not in (cmdline_content.content | b64decode)"
      tags: ['display']
    
    - name: Add fbcon=map:0 to cmdline if not present
      replace:
        path: "{{ cmdline_path }}"
        regexp: '^((?!.*fbcon=map:0).*)$'
        replace: '\1 fbcon=map:0'
      when: 
        - display_type == 'hyperpixel_round'
        - cmdline_path is defined
        - cmdline_content is defined
        - cmdline_content is succeeded
        - cmdline_content.content is defined
        - "'fbcon=map:0' not in (cmdline_content.content | b64decode)"
      tags: ['display']
    
    - name: Add user to required groups for display
      user:
        name: "{{ ansible_user }}"
        groups: spi,i2c,gpio,video
        append: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Configure X server permissions for display
      copy:
        content: |
          allowed_users=anybody
          needs_root_rights=yes
        dest: /etc/X11/Xwrapper.config
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'xorg']
    
    - name: Set permissions for tty1
      file:
        path: /dev/tty1
        mode: '0666'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Verify HyperPixel overlay is installed
      stat:
        path: "{{ overlay_dir }}/hyperpixel2r.dtbo"
      register: overlay_check
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Display HyperPixel installation status
      debug:
        msg: 
          - "HyperPixel installation {{ 'successful' if overlay_check.stat.exists else 'may need manual intervention' }}"
          - "Overlay present: {{ overlay_check.stat.exists | default(false) }}"
          - "Config path: {{ config_path }}"
          - "OS Version: {{ os_version }}"
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    # ============================================
    # Phase 3: Professional Silent Boot Configuration
    # ============================================
    
    # Install required packages for boot splash
    - name: Install boot splash dependencies
      apt:
        name:
          - fbi
          - imagemagick
          - unclutter
        state: present
      tags: ['boot', 'silent']
    
    # Configure completely silent boot
    - name: Backup cmdline.txt
      copy:
        src: /boot/cmdline.txt
        dest: "/boot/cmdline.txt.backup.{{ ansible_date_time.epoch }}"
        remote_src: yes
      tags: ['boot', 'backup']
    
    - name: Configure silent boot parameters
      replace:
        path: /boot/cmdline.txt
        regexp: '^(.*)$'
        replace: '\1 quiet splash fastboot noatime logo.nologo consoleblank=0 loglevel=0 plymouth.enable=0 vt.global_cursor_default=0'
      tags: ['boot', 'silent']
    
    - name: Remove console=tty1 for complete silence
      replace:
        path: /boot/cmdline.txt
        regexp: 'console=tty1\s*'
        replace: ''
      tags: ['boot', 'silent']
    
    - name: Configure silent boot in config.txt
      blockinfile:
        path: /boot/config.txt
        marker: "# {mark} ANSIBLE MANAGED - Silent Boot"
        block: |
          disable_splash=1
          boot_delay=0
          disable_overscan=1
          avoid_warnings=1
      tags: ['boot', 'silent']
    
    # Create boot splash image
    - name: Create boot splash directory
      file:
        path: /usr/share/posthog-pi
        state: directory
        mode: '0755'
      tags: ['boot', 'splash']
    
    - name: Generate professional boot splash image
      shell: |
        convert -size 480x480 xc:'#0d0e1c' \
          -fill '#1d4aff' -draw "circle 240,240 240,160" \
          -fill '#0d0e1c' -draw "circle 240,240 235,160" \
          -fill white -gravity center -pointsize 48 -font "DejaVu-Sans-Bold" -annotate +0+0 "PostHog" \
          /usr/share/posthog-pi/boot-splash.png
      args:
        creates: /usr/share/posthog-pi/boot-splash.png
      tags: ['boot', 'splash']
    
    # Create boot splash service
    - name: Create boot splash service
      copy:
        content: |
          [Unit]
          Description=PostHog Boot Splash Screen
          DefaultDependencies=no
          After=local-fs.target
          Before=getty@tty1.service
          
          [Service]
          Type=oneshot
          ExecStart=/usr/bin/fbi -T 1 -noverbose -a /usr/share/posthog-pi/boot-splash.png
          ExecStartPost=/bin/sleep 1
          StandardOutput=null
          StandardError=null
          RemainAfterExit=yes
          
          [Install]
          WantedBy=sysinit.target
        dest: /etc/systemd/system/boot-splash.service
        mode: '0644'
      tags: ['boot', 'splash']
    
    - name: Enable boot splash service
      systemd:
        name: boot-splash.service
        enabled: yes
        daemon_reload: yes
      tags: ['boot', 'splash']
    
    # Configure silent auto-login
    - name: Create auto-login directory
      file:
        path: /etc/systemd/system/getty@tty1.service.d
        state: directory
        mode: '0755'
      tags: ['boot', 'autologin']
    
    - name: Configure silent auto-login
      copy:
        content: |
          [Service]
          ExecStart=
          ExecStart=-/sbin/agetty --autologin {{ ansible_user }} --noclear --skip-login --nonewline --noissue %I $TERM
          StandardOutput=null
          StandardError=null
        dest: /etc/systemd/system/getty@tty1.service.d/autologin.conf
        mode: '0644'
      tags: ['boot', 'autologin']
    
    # Hide all login messages
    - name: Create empty login message files
      file:
        path: "{{ item }}"
        state: touch
        mode: '0644'
      loop:
        - /etc/issue
        - /etc/issue.net
        - /etc/motd
      tags: ['boot', 'silent']
    
    - name: Clear legal notice
      copy:
        content: ""
        dest: /etc/legal
        mode: '0644'
      tags: ['boot', 'silent']
    
    - name: Create .hushlogin for silent login
      file:
        path: "/home/{{ ansible_user }}/.hushlogin"
        state: touch
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      tags: ['boot', 'silent']
    
    # Optimize boot speed
    - name: Disable unnecessary services for faster boot
      systemd:
        name: "{{ item }}"
        enabled: no
        state: stopped
      loop:
        - bluetooth.service
        - hciuart.service
        - apt-daily.service
        - apt-daily-upgrade.service
        - man-db.service
      ignore_errors: yes
      tags: ['boot', 'optimize']
    
    # ============================================
    # Phase 4: Create swap file for Pi Zero W
    # ============================================
    
    - name: Check if swap file exists
      stat:
        path: /swapfile
      register: swap_file_check
      tags: ['swap']
    
    - name: Create swap file (1GB for Pi Zero W)
      command: |
        dd if=/dev/zero of=/swapfile bs=1M count=1024
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Set swap file permissions
      file:
        path: /swapfile
        mode: '0600'
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Make swap file
      command: mkswap /swapfile
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Enable swap file
      command: swapon /swapfile
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Add swap to fstab
      lineinfile:
        path: /etc/fstab
        line: '/swapfile none swap sw 0 0'
        create: yes
      tags: ['swap']
    
    # ============================================
    # Phase 5: Application Deployment
    # ============================================
    
    - name: Create application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: ['app']
    
    # Archive and copy application files (alternative to synchronize)
    - name: Create temporary archive of application
      archive:
        path: "../"
        dest: "/tmp/pi-analytics-app.tar.gz"
        format: gz
        exclude_path:
          - "../.git"
          - "../node_modules"
          - "../__pycache__"
          - "../*.pyc"
          - "../.env"
          - "../ansible"
          - "../lcd_test"
      delegate_to: localhost
      become: no
      run_once: true
      tags: ['app', 'deploy']
    
    - name: Copy application archive to Pi
      copy:
        src: "/tmp/pi-analytics-app.tar.gz"
        dest: "/tmp/pi-analytics-app.tar.gz"
      tags: ['app', 'deploy']
    
    - name: Extract application files
      unarchive:
        src: "/tmp/pi-analytics-app.tar.gz"
        dest: "{{ app_dir }}"
        remote_src: yes
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      tags: ['app', 'deploy']
    
    - name: Clean up archive on Pi
      file:
        path: "/tmp/pi-analytics-app.tar.gz"
        state: absent
      tags: ['app', 'deploy']
    
    - name: Clean up local archive
      file:
        path: "/tmp/pi-analytics-app.tar.gz"
        state: absent
      delegate_to: localhost
      become: no
      run_once: true
      tags: ['app', 'deploy']
    
    - name: Install Node.js and npm from repository
      apt:
        name:
          - nodejs
          - npm
        state: present
        update_cache: yes
      retries: 3
      delay: 10
      register: nodejs_install
      until: nodejs_install is succeeded
      tags: ['app', 'nodejs']
    
    - name: Check if frontend directory exists
      stat:
        path: "{{ app_dir }}/frontend/package.json"
      register: frontend_package
      tags: ['app', 'frontend']
    
    - name: Install frontend dependencies with memory limit
      shell: |
        cd {{ app_dir }}/frontend
        export NODE_OPTIONS="--max-old-space-size=256"
        npm install --no-audit --no-fund
      args:
        creates: "{{ app_dir }}/frontend/node_modules"
      become_user: "{{ ansible_user }}"
      register: npm_install
      retries: 2
      delay: 10
      until: npm_install.rc == 0
      when: frontend_package.stat.exists
      tags: ['app', 'frontend']
    
    - name: Build frontend with memory limit
      shell: |
        export NODE_OPTIONS="--max-old-space-size=384"
        npm run build
      args:
        chdir: "{{ app_dir }}/frontend"
        creates: "{{ app_dir }}/frontend/build"
      become_user: "{{ ansible_user }}"
      when: frontend_package.stat.exists
      register: npm_build
      retries: 2
      delay: 10
      until: npm_build.rc == 0
      tags: ['app', 'frontend', 'build']
    
    - name: Check if backend directory exists
      stat:
        path: "{{ app_dir }}/backend/requirements.txt"
      register: backend_requirements
      tags: ['app', 'backend']
    
    - name: Remove existing virtual environment if broken
      file:
        path: "{{ app_dir }}/backend/venv"
        state: absent
      when: backend_requirements.stat.exists
      tags: ['app', 'backend']
    
    - name: Create Python virtual environment with pip
      shell: |
        cd {{ app_dir }}/backend
        python3 -m venv venv
        if ! ./venv/bin/python -c "import pip" 2>/dev/null; then
          curl -sS https://bootstrap.pypa.io/get-pip.py | ./venv/bin/python
        fi
      become_user: "{{ ansible_user }}"
      when: backend_requirements.stat.exists
      tags: ['app', 'backend']
    
    - name: Install Python dependencies
      shell: "cd {{ app_dir }}/backend && (./venv/bin/python -m pip install --no-cache-dir -r requirements.txt || ./venv/bin/pip install --no-cache-dir -r requirements.txt)"
      become_user: "{{ ansible_user }}"
      when: backend_requirements.stat.exists
      register: pip_install
      retries: 2
      delay: 10
      until: pip_install.rc == 0
      tags: ['app', 'backend']
    
    - name: Create empty .env file for first-boot configuration
      copy:
        content: |
          # PostHog configuration will be set up on first boot
          # Access the device's web interface to configure
          POSTHOG_API_KEY=
          POSTHOG_PROJECT_ID=
          POSTHOG_HOST=https://app.posthog.com
        dest: "{{ app_dir }}/backend/.env"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      tags: ['app', 'config']
    
    # ============================================
    # Phase 6: System Services Setup
    # ============================================
    
    - name: Create backend service
      template:
        src: templates/pi-analytics-backend.service.j2
        dest: /etc/systemd/system/pi-analytics-backend.service
      tags: ['services', 'backend']
    
    - name: Create kiosk autostart script
      copy:
        content: |
          #!/bin/bash
          # Auto-start script for Pi Analytics Dashboard
          
          # Wait for system to stabilize
          sleep 20
          
          # Start backend if not running
          if ! systemctl is-active pi-analytics-backend >/dev/null 2>&1; then
              systemctl start pi-analytics-backend
          fi
          
          # Wait for backend
          for i in {1..60}; do
              if curl -s http://localhost:5000/api/health >/dev/null 2>&1; then
                  break
              fi
              sleep 1
          done
          
          # Kill any existing X sessions
          killall xinit 2>/dev/null
          killall X 2>/dev/null
          sleep 2
          
          # Start X and kiosk on tty1
          su - {{ ansible_user }} -c "
          export DISPLAY=:0
          xinit {{ app_dir }}/start-kiosk.sh -- :0 -nocursor
          " < /dev/tty1 > /dev/tty1 2>&1 &
        dest: /usr/local/bin/pi-dashboard-autostart.sh
        mode: '0755'
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Add autostart to rc.local
      lineinfile:
        path: /etc/rc.local
        insertbefore: '^exit 0'
        line: '/usr/local/bin/pi-dashboard-autostart.sh &'
        create: yes
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Make rc.local executable
      file:
        path: /etc/rc.local
        mode: '0755'
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Enable rc-local service
      systemd:
        name: rc-local
        enabled: yes
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes
      tags: ['services', 'kiosk']
    
    - name: Create kiosk start script
      template:
        src: templates/start-kiosk.sh.j2
        dest: "{{ app_dir }}/start-kiosk.sh"
        mode: '0755'
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes
      tags: ['services']
    
    - name: Enable and start backend service
      systemd:
        name: pi-analytics-backend
        enabled: yes
        state: started
      tags: ['services', 'backend']
    
    - name: Disable old systemd kiosk service if it exists
      systemd:
        name: pi-analytics-kiosk
        enabled: no
        state: stopped
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes
      tags: ['services', 'kiosk']
    
    # ============================================
    # Phase 7: WiFi Access Point Setup
    # ============================================
    
    - name: Install WiFi AP packages
      apt:
        name:
          - hostapd
          - dnsmasq
          - iw
          - wireless-tools
        state: present
      tags: ['wifi', 'ap']
    
    - name: Copy WiFi AP manager script
      copy:
        src: ../scripts/wifi-ap-manager.sh
        dest: "{{ app_dir }}/scripts/wifi-ap-manager.sh"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: ['wifi', 'ap']
    
    - name: Create WiFi AP manager service
      copy:
        content: |
          [Unit]
          Description=WiFi Access Point Manager
          After=network.target
          Wants=network-online.target
          
          [Service]
          Type=oneshot
          ExecStart={{ app_dir }}/scripts/wifi-ap-manager.sh check
          RemainAfterExit=yes
          StandardOutput=journal
          StandardError=journal
          
          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/wifi-ap-manager.service
        mode: '0644'
      tags: ['wifi', 'ap', 'services']
    
    - name: Create WiFi check timer
      copy:
        content: |
          [Unit]
          Description=Check WiFi connectivity every minute
          Requires=wifi-check.service
          
          [Timer]
          OnBootSec=30
          OnUnitActiveSec=60
          
          [Install]
          WantedBy=timers.target
        dest: /etc/systemd/system/wifi-check.timer
        mode: '0644'
      tags: ['wifi', 'ap', 'services']
    
    - name: Create WiFi check service
      copy:
        content: |
          [Unit]
          Description=Check WiFi and start AP if needed
          
          [Service]
          Type=oneshot
          ExecStart={{ app_dir }}/scripts/wifi-ap-manager.sh check
          StandardOutput=journal
          StandardError=journal
        dest: /etc/systemd/system/wifi-check.service
        mode: '0644'
      tags: ['wifi', 'ap', 'services']
    
    - name: Configure hostapd defaults
      copy:
        content: |
          DAEMON_CONF="/etc/hostapd/hostapd.conf"
        dest: /etc/default/hostapd
        mode: '0644'
      tags: ['wifi', 'ap']
    
    - name: Enable WiFi AP services
      systemd:
        name: "{{ item }}"
        enabled: yes
        daemon_reload: yes
      loop:
        - wifi-ap-manager.service
        - wifi-check.timer
      tags: ['wifi', 'ap', 'services']
    
    - name: Disable conflicting services
      systemd:
        name: "{{ item }}"
        enabled: no
        state: stopped
      loop:
        - hostapd.service
        - dnsmasq.service
      ignore_errors: yes
      tags: ['wifi', 'ap', 'services']
    
    # ============================================
    # Phase 8: Final Configuration
    # ============================================
    
    - name: Set correct permissions on application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        recurse: yes
      tags: ['permissions']
    
    - name: Create log directory
      file:
        path: /var/log/pi-analytics
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: ['logs']
    
    - name: Display installation summary
      debug:
        msg:
          - "====================================="
          - "Pi Analytics Dashboard Installation Complete!"
          - "====================================="
          - ""
          - "Application installed at: {{ app_dir }}"
          - "Backend service: systemctl status pi-analytics-backend"
          - "{{ 'Auto-start: /usr/local/bin/pi-dashboard-autostart.sh' if display_type == 'hyperpixel_round' else 'No display configured' }}"
          - ""
          - "Access the dashboard at: http://{{ ansible_host }}:5000"
          - "Configure PostHog API: http://{{ ansible_host }}:5000/config"
          - ""
          - "{{ 'Display: HyperPixel 2.1 Round with Surf browser (Pi Zero W compatible)' if display_type == 'hyperpixel_round' else '' }}"
          - "{{ 'Note: Reboot required for auto-start display!' if display_type == 'hyperpixel_round' else '' }}"
          - ""
          - "{{ 'Manual start: sudo xinit ' + app_dir + '/start-kiosk.sh -- :0 -nocursor' if display_type == 'hyperpixel_round' else '' }}"
          - ""
          - "{{ 'OS: ' + os_version + ' (HyperPixel works best with Bullseye)' }}"
          - "====================================="
      tags: ['always']
    
  handlers:
    - name: restart backend
      systemd:
        name: pi-analytics-backend
        state: restarted
      
    - name: restart kiosk
      systemd:
        name: pi-analytics-kiosk
        state: restarted