---
# DataOrb Pi Analytics Dashboard - Complete Installation Playbook
# ================================================================
# This playbook automates the complete installation and configuration of DataOrb
# on a Raspberry Pi Zero W with HyperPixel 2.1 Round display.
#
# COMPATIBILITY:
# - Raspberry Pi Zero W (ARMv6)
# - Raspberry Pi OS Bullseye (Legacy) - RECOMMENDED
# - HyperPixel 2.1 Round (480x480)
#
# FEATURES INSTALLED:
# - DataOrb analytics dashboard (React + Flask)
# - HyperPixel display drivers and configuration
# - Auto-start kiosk mode with Surf browser
# - WiFi Access Point fallback for network configuration
# - OTA update system
# - Clean boot experience
#
# USAGE:
# ansible-playbook -i hosts playbook.yml
#
# VARIABLES:
# - app_dir: Installation directory on the Pi
# - display_type: 'hyperpixel_round' or 'none' for headless

- name: Install DataOrb Analytics Dashboard on Raspberry Pi Zero W
  hosts: pi
  become: yes  # Run with sudo privileges
  vars:
    app_dir: /home/{{ ansible_user }}/pi-analytics-dashboard  # Where to install the app
    display_type: hyperpixel_round  # Display configuration: 'hyperpixel_round' or 'none'
    
  tasks:
    # ============================================
    # Phase 1: System Preparation & Dependencies
    # ============================================
    # This phase detects the OS version and installs all required system packages.
    # Critical for ensuring compatibility with different Raspberry Pi OS versions.
    
    - name: Detect OS version
      # Detects the Raspberry Pi OS version (bullseye, bookworm, etc.)
      # This is critical for determining correct config file paths
      shell: |
        if [ -f /etc/os-release ]; then
          . /etc/os-release
          echo ${VERSION_CODENAME:-bullseye}
        else
          echo "unknown"
        fi
      register: os_detection
      changed_when: false  # This is just detection, no changes made
      tags: ['always']  # Always run this task
    
    - name: Set OS version fact
      set_fact:
        os_version: "{{ os_detection.stdout | lower }}"
      tags: ['always']
    
    - name: Display OS version
      debug:
        msg: "Detected OS: {{ os_version }}"
      tags: ['always']
    
    - name: Update package cache
      apt:
        update_cache: yes
        cache_valid_time: 3600
      tags: ['system', 'packages']
    
    - name: Install system dependencies
      # Core system packages required for the application
      apt:
        name:
          - git                      # For OTA updates via git
          - curl                     # For downloading resources
          - wget                     # Alternative downloader
          - unzip                    # For extracting archives
          - build-essential          # Compilation tools for Python packages
          - python3-dev              # Python development headers
          - python3-pip              # Python package installer
          - python3-venv             # Python virtual environments
          - python3-setuptools       # Python package setup tools
          - python3-wheel            # Python wheel package format
          - nginx                    # Web server (optional, not currently used)
          - xorg                     # X Window System
          - xinit                    # X server initializer
          - xserver-xorg-video-all  # Video drivers for X
          - xserver-xorg-input-all  # Input drivers for X
          - x11-xserver-utils        # X server utilities
          - unclutter                # Hide mouse cursor
          - matchbox-window-manager  # Lightweight window manager
          - fbi                      # Framebuffer image viewer
        state: present
      tags: ['system', 'dependencies']
    
    - name: Install lightweight browser for Pi Zero W
      # Surf is a minimal webkit browser perfect for Pi Zero W's limited resources
      # Midori is installed as a backup option
      apt:
        name:
          - surf      # Primary browser - very lightweight, webkit-based
          - midori    # Backup browser option
        state: present
      tags: ['system', 'browser']
    
    # ============================================
    # Phase 2: HyperPixel Display Configuration
    # ============================================
    # Configures the HyperPixel 2.1 Round display (480x480).
    # This is the most complex part as it requires specific kernel overlays
    # and timing configurations. Works best with Bullseye (Legacy OS).
    
    - name: Check OS version for display configuration
      # Different OS versions store boot config in different locations
      # Bullseye and earlier: /boot/
      # Bookworm and later: /boot/firmware/
      set_fact:
        config_path: "{{ '/boot/config.txt' if os_version in ['bullseye', 'buster'] else '/boot/firmware/config.txt' }}"
        overlay_dir: "{{ '/boot/overlays' if os_version in ['bullseye', 'buster'] else '/boot/firmware/overlays' }}"
        cmdline_path: "{{ '/boot/cmdline.txt' if os_version in ['bullseye', 'buster'] else '/boot/firmware/cmdline.txt' }}"
      tags: ['display']
    
    - name: Warn if using incompatible OS for HyperPixel
      debug:
        msg: 
          - "WARNING: HyperPixel 2.1 Round is NOT fully compatible with {{ os_version }}"
          - "For best results, use Raspberry Pi OS Legacy (Bullseye)"
      when: 
        - display_type == 'hyperpixel_round'
        - os_version not in ['bullseye', 'buster']
      tags: ['display']
    
    - name: Backup existing boot configuration
      copy:
        src: "{{ config_path }}"
        dest: "{{ config_path }}.backup.{{ ansible_date_time.epoch }}"
        remote_src: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'backup']
    
    - name: Install HyperPixel dependencies
      # Packages required for HyperPixel display communication and control
      apt:
        name:
          - git                # For cloning HyperPixel repo
          - python3-pip        # Python package manager
          - python3-smbus      # I2C/SMBus support
          - python3-spidev     # SPI interface
          - python3-numpy      # Numerical computations
          - python3-pil        # Python Imaging Library
          - python3-rpi.gpio   # GPIO control
          - i2c-tools          # I2C debugging tools
          - raspi-config       # Raspberry Pi configuration tool
        state: present
        update_cache: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    # Clone and install HyperPixel software
    - name: Clone HyperPixel2r repository
      git:
        repo: https://github.com/pimoroni/hyperpixel2r.git
        dest: /tmp/hyperpixel2r
        force: yes
      when: display_type == 'hyperpixel_round'
      register: hyperpixel_repo
      tags: ['display', 'hyperpixel']
    
    - name: Run HyperPixel installer if it exists
      shell: |
        cd /tmp/hyperpixel2r
        if [ -f install.sh ]; then
          yes | bash install.sh || true
        fi
      when: 
        - display_type == 'hyperpixel_round'
        - hyperpixel_repo is succeeded
      ignore_errors: yes
      tags: ['display', 'hyperpixel']
    
    - name: Copy overlay from repository if needed
      shell: |
        if [ ! -f {{ overlay_dir }}/hyperpixel2r.dtbo ]; then
          if [ -f /tmp/hyperpixel2r/dist/hyperpixel2r.dtbo ]; then
            cp /tmp/hyperpixel2r/dist/hyperpixel2r.dtbo {{ overlay_dir }}/
          fi
        fi
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    # Clean existing configuration
    - name: Remove old HyperPixel configuration
      lineinfile:
        path: "{{ config_path }}"
        regexp: "{{ item }}"
        state: absent
      loop:
        - '.*hyperpixel.*'
        - '^enable_dpi_lcd='
        - '^dpi_group='
        - '^dpi_mode='
        - '^dpi_output_format='
        - '^dpi_timings='
        - '^display_rotate='
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    # Disable conflicting overlays
    - name: Disable conflicting KMS overlay
      replace:
        path: "{{ config_path }}"
        regexp: '^(dtoverlay=vc4-kms-v3d.*)$'
        replace: '#\1  # Disabled for HyperPixel'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Disable FKMS overlay
      replace:
        path: "{{ config_path }}"
        regexp: '^(dtoverlay=vc4-fkms-v3d.*)$'
        replace: '#\1  # Disabled for HyperPixel'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Disable display auto-detect
      replace:
        path: "{{ config_path }}"
        regexp: '^(display_auto_detect=1)$'
        replace: '#\1  # Disabled for HyperPixel'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    # Enable required interfaces
    - name: Enable I2C interface
      lineinfile:
        path: "{{ config_path }}"
        regexp: '^#?dtparam=i2c_arm='
        line: 'dtparam=i2c_arm=on'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Enable SPI interface
      lineinfile:
        path: "{{ config_path }}"
        regexp: '^#?dtparam=spi='
        line: 'dtparam=spi=on'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Enable I2C via raspi-config
      command: raspi-config nonint do_i2c 0
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes
      changed_when: false
      tags: ['display']
    
    - name: Enable SPI via raspi-config
      command: raspi-config nonint do_spi 0
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes
      changed_when: false
      tags: ['display']
    
    - name: Add HyperPixel display configuration
      # Critical display timing configuration for HyperPixel 2.1 Round
      # These values are specific to the 480x480 round display
      blockinfile:
        path: "{{ config_path }}"
        marker: "# {mark} ANSIBLE MANAGED - HyperPixel 2.1 Round Display"
        block: |
          dtoverlay=hyperpixel2r          # Load HyperPixel 2 Round device tree overlay
          enable_dpi_lcd=1                # Enable DPI LCD interface
          dpi_group=2                     # Custom mode group
          dpi_mode=87                     # Custom display mode
          dpi_output_format=0x7f216       # 18-bit RGB format
          dpi_timings=480 0 10 16 55 480 0 15 60 15 0 0 0 60 0 19200000 6  # Display timings
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'hyperpixel']
    
    # Configure console output
    - name: Check cmdline.txt content
      slurp:
        src: "{{ cmdline_path }}"
      register: cmdline_content
      when: 
        - display_type == 'hyperpixel_round'
        - cmdline_path is defined
      ignore_errors: yes
      tags: ['display']
    
    - name: Add console=tty1 to cmdline if not present
      replace:
        path: "{{ cmdline_path }}"
        regexp: '^((?!.*console=tty1).*)$'
        replace: '\1 console=tty1'
      when: 
        - display_type == 'hyperpixel_round'
        - cmdline_path is defined
        - cmdline_content is defined
        - cmdline_content is succeeded
        - cmdline_content.content is defined
        - "'console=tty1' not in (cmdline_content.content | b64decode)"
      tags: ['display']
    
    - name: Add fbcon=map:0 to cmdline if not present
      replace:
        path: "{{ cmdline_path }}"
        regexp: '^((?!.*fbcon=map:0).*)$'
        replace: '\1 fbcon=map:0'
      when: 
        - display_type == 'hyperpixel_round'
        - cmdline_path is defined
        - cmdline_content is defined
        - cmdline_content is succeeded
        - cmdline_content.content is defined
        - "'fbcon=map:0' not in (cmdline_content.content | b64decode)"
      tags: ['display']
    
    - name: Add user to required groups for display
      user:
        name: "{{ ansible_user }}"
        groups: spi,i2c,gpio,video
        append: yes
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Configure X server permissions for display
      copy:
        content: |
          allowed_users=anybody
          needs_root_rights=yes
        dest: /etc/X11/Xwrapper.config
      when: display_type == 'hyperpixel_round'
      tags: ['display', 'xorg']
    
    - name: Set permissions for tty1
      file:
        path: /dev/tty1
        mode: '0666'
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Verify HyperPixel overlay is installed
      stat:
        path: "{{ overlay_dir }}/hyperpixel2r.dtbo"
      register: overlay_check
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    - name: Display HyperPixel installation status
      debug:
        msg: 
          - "HyperPixel installation {{ 'successful' if overlay_check.stat.exists else 'may need manual intervention' }}"
          - "Overlay present: {{ overlay_check.stat.exists | default(false) }}"
          - "Config path: {{ config_path }}"
          - "OS Version: {{ os_version }}"
      when: display_type == 'hyperpixel_round'
      tags: ['display']
    
    # ============================================
    # Phase 3: Clean Boot Configuration
    # ============================================
    # Configures a professional, clean boot experience with no text output.
    # Sets up auto-login and hides all boot messages.
    
    # Install unclutter for hiding cursor
    - name: Install display utilities
      apt:
        name:
          - unclutter
        state: present
      tags: ['boot', 'display']
    
    # Configure completely silent boot
    - name: Backup cmdline.txt
      copy:
        src: /boot/cmdline.txt
        dest: "/boot/cmdline.txt.backup.{{ ansible_date_time.epoch }}"
        remote_src: yes
      tags: ['boot', 'backup']
    
    - name: Configure clean boot parameters
      replace:
        path: /boot/cmdline.txt
        regexp: '^(.*)$'
        replace: '\1 quiet loglevel=3 logo.nologo'
      tags: ['boot', 'clean']
    
    - name: Configure clean boot in config.txt
      blockinfile:
        path: /boot/config.txt
        marker: "# {mark} ANSIBLE MANAGED - Clean Boot"
        block: |
          disable_splash=1
      tags: ['boot', 'clean']
    
    # Configure auto-login
    - name: Create auto-login directory
      file:
        path: /etc/systemd/system/getty@tty1.service.d
        state: directory
        mode: '0755'
      tags: ['boot', 'autologin']
    
    - name: Configure auto-login
      copy:
        content: |
          [Service]
          ExecStart=
          ExecStart=-/sbin/agetty --autologin {{ ansible_user }} --noclear %I $TERM
          Type=idle
        dest: /etc/systemd/system/getty@tty1.service.d/autologin.conf
        mode: '0644'
      tags: ['boot', 'autologin']
    
    # Hide all login messages
    - name: Create empty login message files
      file:
        path: "{{ item }}"
        state: touch
        mode: '0644'
      loop:
        - /etc/issue
        - /etc/issue.net
        - /etc/motd
      tags: ['boot', 'silent']
    
    - name: Clear legal notice
      copy:
        content: ""
        dest: /etc/legal
        mode: '0644'
      tags: ['boot', 'silent']
    
    - name: Create .hushlogin for silent login
      file:
        path: "/home/{{ ansible_user }}/.hushlogin"
        state: touch
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      tags: ['boot', 'silent']
    
    # Optimize boot speed
    - name: Disable unnecessary services for faster boot
      systemd:
        name: "{{ item }}"
        enabled: no
        state: stopped
      loop:
        - bluetooth.service
        - hciuart.service
        - apt-daily.service
        - apt-daily-upgrade.service
        - man-db.service
      ignore_errors: yes
      tags: ['boot', 'optimize']
    
    # ============================================
    # Phase 4: Create swap file for Pi Zero W
    # ============================================
    # Pi Zero W has limited RAM (512MB). A swap file helps prevent
    # out-of-memory errors during npm builds and normal operation.
    
    - name: Check if swap file exists
      stat:
        path: /swapfile
      register: swap_file_check
      tags: ['swap']
    
    - name: Create swap file (1GB for Pi Zero W)
      # Creates a 1GB swap file to supplement the 512MB RAM
      command: |
        dd if=/dev/zero of=/swapfile bs=1M count=1024
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Set swap file permissions
      file:
        path: /swapfile
        mode: '0600'
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Make swap file
      command: mkswap /swapfile
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Enable swap file
      command: swapon /swapfile
      when: not swap_file_check.stat.exists
      tags: ['swap']
    
    - name: Add swap to fstab
      lineinfile:
        path: /etc/fstab
        line: '/swapfile none swap sw 0 0'
        create: yes
      tags: ['swap']
    
    # ============================================
    # Phase 5: Application Deployment
    # ============================================
    # Copies the DataOrb application files to the Pi and installs
    # all Node.js and Python dependencies.
    
    - name: Create application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: ['app']
    
    - name: Create temporary archive of application
      # Creates a compressed archive of the application code, excluding:
      # - Version control files (.git)
      # - Dependencies (node_modules) - will be installed on Pi
      # - Python cache files
      # - Environment files with secrets
      # - Ansible playbooks (not needed on Pi)
      archive:
        path: "../"
        dest: "/tmp/pi-analytics-app.tar.gz"
        format: gz
        exclude_path:
          - "../.git"           # Version control
          - "../node_modules"   # Node dependencies (reinstalled)
          - "../__pycache__"    # Python cache
          - "../*.pyc"          # Compiled Python files
          - "../.env"           # Secrets file
          - "../ansible"        # Deployment files
          - "../lcd_test"       # Test files
      delegate_to: localhost   # Run on control machine
      become: no
      run_once: true
      tags: ['app', 'deploy']
    
    - name: Copy application archive to Pi
      copy:
        src: "/tmp/pi-analytics-app.tar.gz"
        dest: "/tmp/pi-analytics-app.tar.gz"
      tags: ['app', 'deploy']
    
    - name: Extract application files
      unarchive:
        src: "/tmp/pi-analytics-app.tar.gz"
        dest: "{{ app_dir }}"
        remote_src: yes
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      tags: ['app', 'deploy']
    
    - name: Clean up archive on Pi
      file:
        path: "/tmp/pi-analytics-app.tar.gz"
        state: absent
      tags: ['app', 'deploy']
    
    - name: Clean up local archive
      file:
        path: "/tmp/pi-analytics-app.tar.gz"
        state: absent
      delegate_to: localhost
      become: no
      run_once: true
      tags: ['app', 'deploy']
    
    - name: Install Node.js and npm from repository
      apt:
        name:
          - nodejs
          - npm
        state: present
        update_cache: yes
      retries: 3
      delay: 10
      register: nodejs_install
      until: nodejs_install is succeeded
      tags: ['app', 'nodejs']
    
    - name: Check if frontend directory exists
      stat:
        path: "{{ app_dir }}/frontend/package.json"
      register: frontend_package
      tags: ['app', 'frontend']
    
    - name: Install frontend dependencies with memory limit
      # Pi Zero W has limited memory, so we restrict Node.js heap size
      # --no-audit and --no-fund speed up installation
      shell: |
        cd {{ app_dir }}/frontend
        export NODE_OPTIONS="--max-old-space-size=256"  # Limit to 256MB heap
        npm install --no-audit --no-fund                 # Skip security audit and funding messages
      args:
        creates: "{{ app_dir }}/frontend/node_modules"  # Skip if already installed
      become_user: "{{ ansible_user }}"
      register: npm_install
      retries: 2        # Retry on failure (network issues)
      delay: 10         # Wait 10 seconds between retries
      until: npm_install.rc == 0
      when: frontend_package.stat.exists
      tags: ['app', 'frontend']
    
    - name: Build frontend with memory limit
      # Build the React app with optimized memory settings for Pi Zero W
      shell: |
        export NODE_OPTIONS="--max-old-space-size=384"  # Slightly more memory for build process
        npm run build
      args:
        chdir: "{{ app_dir }}/frontend"
        creates: "{{ app_dir }}/frontend/build"  # Skip if build exists
      become_user: "{{ ansible_user }}"
      when: frontend_package.stat.exists
      register: npm_build
      retries: 2        # Retry on failure
      delay: 10
      until: npm_build.rc == 0
      tags: ['app', 'frontend', 'build']
    
    - name: Check if backend directory exists
      stat:
        path: "{{ app_dir }}/backend/requirements.txt"
      register: backend_requirements
      tags: ['app', 'backend']
    
    - name: Remove existing virtual environment if broken
      file:
        path: "{{ app_dir }}/backend/venv"
        state: absent
      when: backend_requirements.stat.exists
      tags: ['app', 'backend']
    
    - name: Create Python virtual environment with pip
      # Creates isolated Python environment for backend dependencies
      # Includes fallback to install pip if not present in venv
      shell: |
        cd {{ app_dir }}/backend
        python3 -m venv venv                              # Create virtual environment
        if ! ./venv/bin/python -c "import pip" 2>/dev/null; then
          # If pip is missing, install it manually
          curl -sS https://bootstrap.pypa.io/get-pip.py | ./venv/bin/python
        fi
      become_user: "{{ ansible_user }}"
      when: backend_requirements.stat.exists
      tags: ['app', 'backend']
    
    - name: Install Python dependencies
      shell: "cd {{ app_dir }}/backend && (./venv/bin/python -m pip install --no-cache-dir -r requirements.txt || ./venv/bin/pip install --no-cache-dir -r requirements.txt)"
      become_user: "{{ ansible_user }}"
      when: backend_requirements.stat.exists
      register: pip_install
      retries: 2
      delay: 10
      until: pip_install.rc == 0
      tags: ['app', 'backend']
    
    - name: Create empty .env file for first-boot configuration
      # Creates placeholder .env file - actual API credentials
      # will be configured via web interface on first boot
      copy:
        content: |
          # DataOrb configuration will be set up on first boot
          # Access the device's web interface to configure
          POSTHOG_API_KEY=         # Will be configured via web UI
          POSTHOG_PROJECT_ID=      # Will be configured via web UI
          POSTHOG_HOST=https://app.posthog.com  # Default host
        dest: "{{ app_dir }}/backend/.env"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      tags: ['app', 'config']
    
    # ============================================
    # Phase 6: System Services Setup
    # ============================================
    # Sets up systemd services and auto-start scripts for the dashboard.
    # Includes X server configuration and kiosk mode setup.
    
    # Install X server and display tools
    - name: Install X server and display tools
      apt:
        name:
          - xserver-xorg
          - xinit
          - x11-xserver-utils
          - matchbox-window-manager
          - unclutter
          - surf
        state: present
      tags: ['display', 'xorg']
    
    - name: Create backend service
      template:
        src: templates/pi-analytics-backend.service.j2
        dest: /etc/systemd/system/pi-analytics-backend.service
      tags: ['services', 'backend']
    
    - name: Create kiosk autostart script
      # Main auto-start script that runs on boot
      copy:
        content: |
          #!/bin/bash
          # Auto-start script for DataOrb Analytics Dashboard
          
          # Wait for system to stabilize after boot
          sleep 20
          
          # Ensure backend service is running
          if ! systemctl is-active pi-analytics-backend >/dev/null 2>&1; then
              systemctl start pi-analytics-backend
          fi
          
          # Wait for backend API to be ready (max 60 seconds)
          for i in {1..60}; do
              if curl -s http://localhost:5000/api/health >/dev/null 2>&1; then
                  break
              fi
              sleep 1
          done
          
          # Clean up any existing X sessions
          killall xinit 2>/dev/null
          killall X 2>/dev/null
          sleep 2
          
          # Start X server and kiosk browser on tty1 (physical display)
          su - {{ ansible_user }} -c "
          export DISPLAY=:0
          xinit {{ app_dir }}/start-kiosk.sh -- :0 -nocursor
          " < /dev/tty1 > /dev/tty1 2>&1 &
        dest: /usr/local/bin/pi-dashboard-autostart.sh
        mode: '0755'
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Add autostart to rc.local
      lineinfile:
        path: /etc/rc.local
        insertbefore: '^exit 0'
        line: '/usr/local/bin/pi-dashboard-autostart.sh &'
        create: yes
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Make rc.local executable
      file:
        path: /etc/rc.local
        mode: '0755'
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Enable rc-local service
      systemd:
        name: rc-local
        enabled: yes
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes
      tags: ['services', 'kiosk']
    
    - name: Create kiosk start script
      template:
        src: templates/start-kiosk.sh.j2
        dest: "{{ app_dir }}/start-kiosk.sh"
        mode: '0755'
      when: display_type == 'hyperpixel_round'
      tags: ['services', 'kiosk']
    
    - name: Create X launcher script
      copy:
        content: |
          #!/bin/bash
          # X session launcher for DataOrb Dashboard
          
          # Wait for X to be ready
          sleep 2
          
          # Disable screen blanking
          xset -dpms 2>/dev/null || true
          xset s off 2>/dev/null || true
          xset s noblank 2>/dev/null || true
          
          # Hide cursor
          unclutter -idle 0 &
          
          # Start window manager
          matchbox-window-manager -use_titlebar no -use_cursor no &
          sleep 2
          
          # Launch surf browser in fullscreen
          surf -F http://localhost:5000
        dest: "{{ app_dir }}/launch-x.sh"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: ['services', 'kiosk']
    
    - name: Configure auto-start in user's .bashrc
      # Alternative auto-start method via .bashrc
      # This runs when the user logs in on tty1 (the physical display)
      blockinfile:
        path: "/home/{{ ansible_user }}/.bashrc"
        marker: "# {mark} ANSIBLE MANAGED - DataOrb Dashboard Auto-start"
        block: |
          # Auto-start DataOrb Dashboard on tty1 (physical display)
          if [ "$(tty 2>/dev/null)" = "/dev/tty1" ]; then
              # Only start if X server not already running
              if ! pgrep -x "Xorg" > /dev/null; then
                  echo "Starting DataOrb Dashboard..."
                  cd {{ app_dir }}
                  startx ./launch-x.sh -- :0 vt1  # Start X on virtual terminal 1
              fi
          fi
      tags: ['services', 'kiosk', 'autostart']
    
    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes
      tags: ['services']
    
    - name: Enable and start backend service
      systemd:
        name: pi-analytics-backend
        enabled: yes
        state: started
      tags: ['services', 'backend']
    
    - name: Disable old systemd kiosk service if it exists
      # Clean up old service from previous installations
      # ignore_errors because service might not exist on fresh installs
      systemd:
        name: pi-analytics-kiosk
        enabled: no
        state: stopped
      when: display_type == 'hyperpixel_round'
      ignore_errors: yes  # Don't fail if service doesn't exist
      tags: ['services', 'kiosk']
    
    # ============================================
    # Phase 7: WiFi Access Point Setup
    # ============================================
    # Configures automatic WiFi Access Point mode when no network is available.
    # This allows users to connect to the Pi and configure WiFi settings
    # even when it's not connected to a network.
    
    - name: Install WiFi AP packages
      # Packages needed to create a WiFi access point
      apt:
        name:
          - hostapd         # Access point daemon
          - dnsmasq         # DHCP and DNS server
          - iw              # Wireless configuration tool
          - wireless-tools  # Legacy wireless tools
        state: present
      tags: ['wifi', 'ap']
    
    - name: Copy WiFi AP manager script
      copy:
        src: ../scripts/wifi-ap-manager.sh
        dest: "{{ app_dir }}/scripts/wifi-ap-manager.sh"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: ['wifi', 'ap']
    
    - name: Create WiFi AP manager service
      # Service that checks network connectivity and starts AP if needed
      copy:
        content: |
          [Unit]
          Description=WiFi Access Point Manager
          After=network.target           # Run after network is up
          Wants=network-online.target    # Want network to be online
          
          [Service]
          Type=oneshot                   # Run once and exit
          ExecStart={{ app_dir }}/scripts/wifi-ap-manager.sh check
          RemainAfterExit=yes            # Keep service active after exit
          StandardOutput=journal         # Log to systemd journal
          StandardError=journal
          
          [Install]
          WantedBy=multi-user.target     # Start in normal boot
        dest: /etc/systemd/system/wifi-ap-manager.service
        mode: '0644'
      tags: ['wifi', 'ap', 'services']
    
    - name: Create WiFi check timer
      copy:
        content: |
          [Unit]
          Description=Check WiFi connectivity every minute
          Requires=wifi-check.service
          
          [Timer]
          OnBootSec=30
          OnUnitActiveSec=60
          
          [Install]
          WantedBy=timers.target
        dest: /etc/systemd/system/wifi-check.timer
        mode: '0644'
      tags: ['wifi', 'ap', 'services']
    
    - name: Create WiFi check service
      copy:
        content: |
          [Unit]
          Description=Check WiFi and start AP if needed
          
          [Service]
          Type=oneshot
          ExecStart={{ app_dir }}/scripts/wifi-ap-manager.sh check
          StandardOutput=journal
          StandardError=journal
        dest: /etc/systemd/system/wifi-check.service
        mode: '0644'
      tags: ['wifi', 'ap', 'services']
    
    - name: Configure hostapd defaults
      copy:
        content: |
          DAEMON_CONF="/etc/hostapd/hostapd.conf"
        dest: /etc/default/hostapd
        mode: '0644'
      tags: ['wifi', 'ap']
    
    - name: Enable WiFi AP services
      systemd:
        name: "{{ item }}"
        enabled: yes
        daemon_reload: yes
      loop:
        - wifi-ap-manager.service
        - wifi-check.timer
      tags: ['wifi', 'ap', 'services']
    
    - name: Disable conflicting services
      # Disable default hostapd/dnsmasq services as we manage them manually
      systemd:
        name: "{{ item }}"
        enabled: no
        state: stopped
      loop:
        - hostapd.service    # We start this manually when needed
        - dnsmasq.service    # We start this manually when needed
      ignore_errors: yes     # Services might not exist
      tags: ['wifi', 'ap', 'services']
    
    # ============================================
    # Phase 8: Final Configuration
    # ============================================
    # Final permission fixes, log directory creation, and
    # installation summary display.
    
    - name: Set correct permissions on application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        recurse: yes
      tags: ['permissions']
    
    - name: Create log directory
      file:
        path: /var/log/pi-analytics
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: ['logs']
    
    - name: Display installation summary
      # Show helpful information about the completed installation
      debug:
        msg:
          - "====================================="
          - "DataOrb Analytics Dashboard Installation Complete!"
          - "====================================="
          - ""
          - "Application installed at: {{ app_dir }}"
          - "Backend service: systemctl status pi-analytics-backend"
          - "{{ 'Auto-start: /usr/local/bin/pi-dashboard-autostart.sh' if display_type == 'hyperpixel_round' else 'No display configured' }}"
          - ""
          - "Access the dashboard at: http://{{ ansible_host }}:5000"
          - "Configure DataOrb API: http://{{ ansible_host }}:5000/config"
          - ""
          - "WiFi AP Mode (when no network):"
          - "  SSID: DataOrb-Setup"
          - "  Password: dataorb123"
          - "  Config URL: http://192.168.4.1:5000"
          - ""
          - "{{ 'Display: HyperPixel 2.1 Round with Surf browser (Pi Zero W compatible)' if display_type == 'hyperpixel_round' else '' }}"
          - "{{ 'Note: Reboot required for auto-start display!' if display_type == 'hyperpixel_round' else '' }}"
          - ""
          - "{{ 'Manual start: sudo xinit ' + app_dir + '/start-kiosk.sh -- :0 -nocursor' if display_type == 'hyperpixel_round' else '' }}"
          - ""
          - "{{ 'OS: ' + os_version + ' (HyperPixel works best with Bullseye)' }}"
          - "====================================="
      tags: ['always']
    
  # Handlers are triggered by tasks using 'notify'
  # They run at the end of the play
  handlers:
    - name: restart backend
      systemd:
        name: pi-analytics-backend
        state: restarted
      
    - name: restart kiosk
      systemd:
        name: pi-analytics-kiosk
        state: restarted